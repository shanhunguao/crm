package com.ykhd.office.component.timertask;

import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;
import com.ykhd.office.domain.entity.Customer;
import com.ykhd.office.domain.entity.WorkTask;
import com.ykhd.office.service.IWorkTaskService;
import com.ykhd.office.service.impl.CustomerService;
import com.ykhd.office.util.DateUtil;
import com.ykhd.office.util.dictionary.StateEnums.State4WorkTask;

/**
 * @author zhoufan
 * @Date 2020/9/12
 */
@Component
@EnableScheduling
public class MyTask {

    private static final Logger LOGGER = LoggerFactory.getLogger(MyTask.class);

    @Autowired
    private CustomerService customerService;
    @Autowired
    private IWorkTaskService workTaskService;

//    /**
//     * 创建TaskScheduler Bean
//     */
//    @Bean
//    public TaskScheduler scheduledExecutorService() {
//        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
//        scheduler.setPoolSize(8);
//        scheduler.setThreadNamePrefix("scheduled-thread-");
//        return scheduler;
//    }
//
//    /**
//     * 两个月不存在排期的客户信息自动掉入公海
//     * cron表达式 每个月的最后一天10：15”执行定时任务
//     */
//    @Scheduled(cron = "0 15 10 28-31 * ?")
//    public void task() {
//        try {
//            final Calendar c = Calendar.getInstance();
//            //判断是否是最后一天
//            if (c.get(Calendar.DATE) == c.getActualMaximum(Calendar.DATE)) {
//                LOGGER.info("当前时间:", System.currentTimeMillis());
//                List<Customer> list = customerService.toHighseasCustomer();
//                if (list != null && !list.isEmpty()) {
//                    for (Customer customer : list) {
//                        UpdateWrapper<Customer> customerUpdateWrapper = new UpdateWrapper<>();
//                        customerUpdateWrapper.set("belong_user", null);
//                        customerUpdateWrapper.set("is_lock", 1);
//                        customerUpdateWrapper.set("high_sea_time", new Date());
//                        customerUpdateWrapper.eq("id", customer.getId());
//                        //修改客户信息
//                        customerService.update(customer, customerUpdateWrapper);
//                    }
//                }
//            }
//        } catch (Exception e) {
//            LOGGER.info("定时任务调用失败!");
//        }
//    }

    /**
     * 检测进行中的工作任务是否延期
     */
    @Scheduled(cron = "0 1 0 * * ?")
    public void checkWorkTask() {
        LOGGER.info("自动检测进行中的工作任务是否延期");
        Date short_date = DateUtil.yyyyMMdd2date(DateUtil.date2yyyyMMdd(new Date()));
        List<WorkTask> all = workTaskService.list(new QueryWrapper<WorkTask>().select("id", "plan_finish_date").eq("state", State4WorkTask.进行中.code()));
        List<Integer> ids = all.stream().filter(v -> DateUtil.yyyyMMdd2date(v.getPlanFinishDate()).before(short_date)).map(WorkTask::getId).collect(Collectors.toList());
        LOGGER.info("延期任务数：" + ids.size());
        if (!ids.isEmpty())
            if (workTaskService.update(new UpdateWrapper<WorkTask>().in("id", ids).set("state", State4WorkTask.延期.code())))
                LOGGER.info("延期更改完成");
    }

    /**
     * 两个月不存在排期的客户信息自动掉入公海
     */
    @Scheduled(cron = "0 5 0 * * ?")
    public void backHighSeas() {
        Date now = new Date();
        List<Customer> list = customerService.list(new QueryWrapper<Customer>().select("id", "draw_time").eq("is_lock", "0"));
        List<Integer> customerId = list.stream().filter(v -> v.getDrawTime().before(DateUtil.monthsAgo(now, 2))).map(Customer::getId).collect(Collectors.toList());
        if (customerId.size() > 0) {
            LOGGER.info("掉入公海的客户数量：" + customerId.size());
            customerService.update(new UpdateWrapper<Customer>().in("id", customerId).set("is_lock", "1").set("draw_time", null).set("belong_user", null));
        }
    }

}
